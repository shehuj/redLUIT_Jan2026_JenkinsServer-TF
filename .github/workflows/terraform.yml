# ========================================================================
# Terraform CI/CD Workflow
# ========================================================================
#
# This workflow provides production-ready Terraform automation with:
# - Automated planning and applying of infrastructure changes
# - Security scanning (tfsec, Checkov)
# - PR plan comments
# - Environment-based approval gates
# - Artifact storage for plan review
#
# ========================================================================
# SETUP INSTRUCTIONS
# ========================================================================
#
# 1. Configure GitHub Secrets (Settings > Secrets and variables > Actions)
#
#    Required Secrets:
#    - AWS_ACCESS_KEY_ID: AWS access key (or use OIDC role)
#    - AWS_SECRET_ACCESS_KEY: AWS secret key (or use OIDC role)
#    - AWS_REGION: AWS region (e.g., us-east-1)
#    - PUBLIC_IP: Your public IP in CIDR format (e.g., 203.0.113.42/32)
#    - JENKINS_S3_BUCKET_NAME: Unique S3 bucket name for Jenkins artifacts
#    - ENVIRONMENT: Environment name (dev, staging, prod)
#    - JENKINS_UI_CIDRS: JSON array of CIDR blocks (e.g., ["203.0.113.0/24"])
#
#    Optional (for OIDC - recommended):
#    - AWS_ROLE_ARN: IAM role ARN for OIDC authentication
#
# 2. Configure GitHub Environments (Settings > Environments)
#
#    Create two environments:
#
#    A. "production" environment:
#       - Protection rules:
#         âœ“ Required reviewers: Add team members who must approve
#         âœ“ Wait timer: Optional delay before deployment (e.g., 5 minutes)
#         âœ“ Deployment branches: Only "main" branch
#       - Environment secrets: Use production values
#
#    B. "development" environment:
#       - Protection rules: None (auto-deploy on PR)
#       - Environment secrets: Use development values
#
# 3. Backend Configuration
#
#    Before first run:
#    - Run: cd terraform && ./setup-backend.sh
#    - Update backend.tf with actual S3 bucket and DynamoDB table
#    - Uncomment backend block in backend.tf
#    - Run: terraform init -migrate-state
#
# 4. Enable Security Scanning (Settings > Code security and analysis)
#
#    - Enable "Dependency graph"
#    - Enable "Dependabot alerts"
#    - Enable "Code scanning" (for SARIF uploads from tfsec/Checkov)
#
# ========================================================================
# WORKFLOW TRIGGERS
# ========================================================================
#
# - Pull Request: Runs plan, format check, validate, and security scans
# - Push to main: Runs full workflow including apply (with approval for prod)
#
# ========================================================================

name: 'Terraform'

on:
  push:
    branches: [ "main" ]
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'
  pull_request:
    paths:
      - 'terraform/**'
      - '.github/workflows/terraform.yml'

permissions:
  contents: read
  id-token: write  # Required for OIDC authentication
  pull-requests: write  # Required for PR comments

jobs:
  terraform:
    name: 'Terraform'
    runs-on: ubuntu-latest
    # Dynamic environment selection based on ENVIRONMENT secret
    # Configure protection rules in GitHub Settings > Environments
    # For production: require reviewers, add deployment branches rule
    environment:
      name: ${{ github.event_name == 'push' && 'production' || 'development' }}
      url: ${{ steps.apply.outputs.jenkins_url }}

    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v4

    # Configure AWS credentials using OIDC (recommended) or access keys
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        # For OIDC (recommended - no long-lived credentials):
        # role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        # For access keys (alternative):
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    # Create terraform.tfvars from GitHub secrets
    - name: Create terraform.tfvars
      run: |
        cat > terraform.tfvars <<EOF
        aws_region             = "${{ secrets.AWS_REGION }}"
        public_ip              = "${{ secrets.PUBLIC_IP }}"
        jenkins_s3_bucket_name = "${{ secrets.JENKINS_S3_BUCKET_NAME }}"
        environment            = "${{ secrets.ENVIRONMENT }}"
        jenkins_ui_cidrs       = ${{ secrets.JENKINS_UI_CIDRS }}
        EOF

    # Install the latest version of Terraform CLI
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3

    # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      run: terraform init

    # Checks that all Terraform configuration files adhere to a canonical format
    - name: Terraform Format
      run: terraform fmt -check -recursive

    # Validate Terraform configuration files
    - name: Terraform Validate
      run: terraform validate

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -input=false -no-color -out=tfplan
        terraform show -no-color tfplan
      continue-on-error: true

    # Upload plan artifact for review
    - name: Upload Plan Artifact
      if: github.event_name == 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: terraform/tfplan
        retention-days: 30

    # Comment plan output on PR
    - name: Comment Plan on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const output = `#### Terraform Plan ðŸ“

          <details><summary>Show Plan</summary>

          \`\`\`terraform
          ${{ steps.plan.outputs.stdout }}
          \`\`\`

          </details>

          *Pushed by: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          })

    # On push to "main", build or change infrastructure according to Terraform configuration files
    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && github.event_name == 'push'
      run: terraform apply -auto-approve -input=false tfplan

  # Security scanning job - runs in parallel with terraform job
  security:
    name: 'Security Scanning'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write  # Required for uploading SARIF results
      pull-requests: write

    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    # Run tfsec for security scanning
    - name: Run tfsec
      uses: aquasecurity/tfsec-action@v1.0.3
      with:
        working_directory: terraform
        soft_fail: false  # Fail workflow on security issues
        format: sarif
        additional_args: --minimum-severity MEDIUM

    # Upload tfsec results to GitHub Security tab
    - name: Upload tfsec SARIF
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: results.sarif
        category: tfsec

    # Run Checkov for compliance scanning
    - name: Run Checkov
      uses: bridgecrewio/checkov-action@v12
      with:
        directory: terraform
        framework: terraform
        output_format: sarif
        output_file_path: checkov-results.sarif
        soft_fail: true  # Don't fail on checkov issues, just report
        quiet: false
        download_external_modules: true

    # Upload Checkov results to GitHub Security tab
    - name: Upload Checkov SARIF
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: checkov-results.sarif
        category: checkov

    # Generate security summary
    - name: Security Summary
      if: always()
      run: |
        echo "## Security Scan Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "âœ… tfsec scan completed" >> $GITHUB_STEP_SUMMARY
        echo "âœ… Checkov scan completed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "View detailed results in the Security tab" >> $GITHUB_STEP_SUMMARY
