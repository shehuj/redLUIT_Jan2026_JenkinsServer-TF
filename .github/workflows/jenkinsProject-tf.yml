name: Terraform Apply - jenkinsProject

on:
  workflow_dispatch:
  pull_request:
    branches:
      - main
    paths:
      - 'jenkinsProject/terraform/**'
      - '.github/workflows/jenkinsProject-tf.yml'

jobs:
  terraform:
    runs-on: ubuntu-latest
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: "1.5.0"
        terraform_wrapper: false

    - name: Check and Fix Terraform State
      run: |
        set +e  # Don't exit on error, we want to handle it
        cd ./jenkinsProject/terraform

        echo "ðŸ” Checking Terraform state integrity..."

        # Configuration
        STATE_KEY="jenkins-states/default/infra.tfstate"
        BUCKET="${{ secrets.TF_BACKEND_BUCKET }}"
        TABLE="${{ secrets.TF_DYNAMODB_TABLE }}"
        REGION="${{ secrets.AWS_REGION }}"

        # Try to initialize and capture output
        terraform init \
          -backend-config="bucket=${BUCKET}" \
          -backend-config="region=${REGION}" \
          -backend-config="dynamodb_table=${TABLE}" > init_output.txt 2>&1

        INIT_EXIT_CODE=$?

        # If init failed, check for state issues
        if [ $INIT_EXIT_CODE -ne 0 ]; then
          cat init_output.txt

          # Check if it's a checksum/state mismatch error
          if grep -q -i "checksum\|state data in S3 does not have the expected content\|Digest value" init_output.txt; then
            echo ""
            echo "âš ï¸ State checksum mismatch detected!"
            echo "ðŸ§¹ Cleaning up corrupted state..."
            echo ""

            # Delete corrupted state file from S3
            echo "ðŸ“¦ Removing corrupted state file from S3..."
            aws s3 rm "s3://${BUCKET}/${STATE_KEY}" --region "${REGION}" 2>/dev/null && \
              echo "âœ… State file removed" || echo "âš ï¸ State file not found (may already be deleted)"

            # Clear all possible DynamoDB lock entries
            echo "ðŸ” Clearing DynamoDB lock entries..."

            # Try different lock ID formats
            for lock_id in \
              "${BUCKET}/${STATE_KEY}-md5" \
              "${BUCKET}/${STATE_KEY}" \
              "${STATE_KEY}-md5" \
              "${STATE_KEY}"; do

              aws dynamodb delete-item \
                --table-name "${TABLE}" \
                --key "{\"LockID\": {\"S\": \"${lock_id}\"}}" \
                --region "${REGION}" 2>/dev/null && \
                echo "âœ… Cleared lock: ${lock_id}" || true
            done

            # Scan and delete any remaining items for this state
            echo "ðŸ” Scanning for remaining locks..."
            aws dynamodb scan \
              --table-name "${TABLE}" \
              --region "${REGION}" \
              --filter-expression "contains(LockID, :state_key)" \
              --expression-attribute-values "{\":state_key\":{\"S\":\"${STATE_KEY}\"}}" \
              --projection-expression "LockID" 2>/dev/null | \
              jq -r '.Items[]?.LockID.S' 2>/dev/null | \
              while read -r lock_id; do
                if [ -n "$lock_id" ]; then
                  aws dynamodb delete-item \
                    --table-name "${TABLE}" \
                    --key "{\"LockID\": {\"S\": \"${lock_id}\"}}" \
                    --region "${REGION}" 2>/dev/null && \
                    echo "âœ… Cleared additional lock: ${lock_id}" || true
                fi
              done

            echo ""
            echo "âœ… State cleanup complete!"
            echo "state_was_cleaned=true" >> $GITHUB_ENV

          else
            echo ""
            echo "âŒ Terraform init failed for a different reason (not state corruption)"
            echo "Please check the error above"
            rm -f init_output.txt
            exit 1
          fi
        else
          echo "âœ… State is healthy - no cleanup needed"
          echo "state_was_cleaned=false" >> $GITHUB_ENV
        fi

        rm -f init_output.txt
        set -e  # Re-enable exit on error

    - name: Terraform Init
      run: |
        cd ./jenkinsProject/terraform
        terraform init \
          -backend-config="bucket=${{ secrets.TF_BACKEND_BUCKET }}" \
          -backend-config="region=${{ secrets.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ secrets.TF_DYNAMODB_TABLE }}"

    - name: State Cleanup Notification
      if: env.state_was_cleaned == 'true'
      run: |
        echo "## âš ï¸ State Cleanup Performed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "A corrupted Terraform state was detected and automatically cleaned." >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Actions taken:**" >> $GITHUB_STEP_SUMMARY
        echo "- Removed corrupted state file from S3" >> $GITHUB_STEP_SUMMARY
        echo "- Cleared DynamoDB checksum entries" >> $GITHUB_STEP_SUMMARY
        echo "- Re-initialized Terraform with clean state" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Note:** Any existing infrastructure will need to be imported or recreated." >> $GITHUB_STEP_SUMMARY

    - name: Terraform Validate
      run: |
        cd ./jenkinsProject/terraform
        terraform validate

    - name: Terraform Plan
      run: |
        cd ./jenkinsProject/terraform
        terraform plan -out=tfplan

    - name: Upload Plan Artifact
      uses: actions/upload-artifact@v4
      with:
        name: jenkinsProject-plan-${{ github.sha }}
        path: jenkinsProject/terraform/tfplan
        retention-days: 7

    - name: Terraform Apply
      run: |
        cd ./jenkinsProject/terraform
        terraform apply -auto-approve tfplan

    - name: Capture Terraform Outputs
      id: tf_outputs
      run: |
        cd ./jenkinsProject/terraform

        # Capture outputs without debug noise
        JENKINS_PUBLIC_IP=$(terraform output -raw jenkins_public_ip 2>/dev/null || echo "")
        JENKINS_PRIVATE_IP=$(terraform output -raw jenkins_private_ip 2>/dev/null || echo "")
        JENKINS_INSTANCE_ID=$(terraform output -raw jenkins_instance_id 2>/dev/null || echo "")
        ARTIFACTS_BUCKET=$(terraform output -raw jenkins_artifacts_bucket_name 2>/dev/null || echo "")

        # Validate outputs
        if [[ -z "${JENKINS_PUBLIC_IP}" ]] || [[ -z "${JENKINS_INSTANCE_ID}" ]]; then
          echo "âŒ Error: Failed to retrieve Terraform outputs"
          echo "Public IP: '${JENKINS_PUBLIC_IP}'"
          echo "Private IP: '${JENKINS_PRIVATE_IP}'"
          echo "Instance ID: '${JENKINS_INSTANCE_ID}'"
          echo "Artifacts Bucket: '${ARTIFACTS_BUCKET}'"
          terraform output
          exit 1
        fi

        # Validate IP formats
        if [[ ! "${JENKINS_PUBLIC_IP}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Error: Invalid public IP format: '${JENKINS_PUBLIC_IP}'"
          exit 1
        fi

        if [[ ! "${JENKINS_PRIVATE_IP}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "âŒ Error: Invalid private IP format: '${JENKINS_PRIVATE_IP}'"
          exit 1
        fi

        # Export to outputs
        echo "jenkins_public_ip=${JENKINS_PUBLIC_IP}" >> $GITHUB_OUTPUT
        echo "jenkins_private_ip=${JENKINS_PRIVATE_IP}" >> $GITHUB_OUTPUT
        echo "jenkins_instance_id=${JENKINS_INSTANCE_ID}" >> $GITHUB_OUTPUT
        echo "artifacts_bucket=${ARTIFACTS_BUCKET}" >> $GITHUB_OUTPUT

        echo "ðŸ“ Jenkins Public IP: ${JENKINS_PUBLIC_IP}"
        echo "ðŸ”’ Jenkins Private IP: ${JENKINS_PRIVATE_IP}"
        echo "ðŸ†” Jenkins Instance ID: ${JENKINS_INSTANCE_ID}"
        echo "ðŸª£ Artifacts Bucket: ${ARTIFACTS_BUCKET}"

    - name: Save Jenkins Connection Info
      run: |
        mkdir -p outputs
        echo "${{ steps.tf_outputs.outputs.jenkins_public_ip }}" > outputs/jenkins_public_ip.txt
        echo "${{ steps.tf_outputs.outputs.jenkins_private_ip }}" > outputs/jenkins_private_ip.txt
        echo "${{ steps.tf_outputs.outputs.jenkins_instance_id }}" > outputs/jenkins_instance_id.txt
        echo "${{ steps.tf_outputs.outputs.artifacts_bucket }}" > outputs/jenkins_artifacts_bucket.txt

    - name: Upload Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: jenkinsProject-outputs-${{ github.sha }}
        path: outputs/
        retention-days: 7

    - name: Deployment Summary
      run: |
        echo "## ðŸš€ JenkinsProject Infrastructure Deployment Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“‹ Deployment Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Public IP**: ${{ steps.tf_outputs.outputs.jenkins_public_ip }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Private IP**: ${{ steps.tf_outputs.outputs.jenkins_private_ip }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Instance ID**: ${{ steps.tf_outputs.outputs.jenkins_instance_id }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Artifacts Bucket**: \`${{ steps.tf_outputs.outputs.artifacts_bucket }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸŒ Access Information" >> $GITHUB_STEP_SUMMARY
        echo "- **Jenkins URL**: http://${{ steps.tf_outputs.outputs.jenkins_public_ip }}:8080" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ” Server Access" >> $GITHUB_STEP_SUMMARY
        echo "**Via AWS Systems Manager (Recommended - No SSH port needed):**" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
        echo "aws ssm start-session --target ${{ steps.tf_outputs.outputs.jenkins_instance_id }}" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Via SSH:**" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
        echo "ssh -i ~/.ssh/key.pem ubuntu@${{ steps.tf_outputs.outputs.jenkins_public_ip }}" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸª£ S3 Artifacts Bucket" >> $GITHUB_STEP_SUMMARY
        echo "- **Bucket Name**: \`${{ steps.tf_outputs.outputs.artifacts_bucket }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **Access**: Private (blocked from public access)" >> $GITHUB_STEP_SUMMARY
        echo "- **Encryption**: AES256 server-side encryption enabled" >> $GITHUB_STEP_SUMMARY
        echo "- **Versioning**: Enabled" >> $GITHUB_STEP_SUMMARY
        echo "- **Lifecycle**: Artifacts deleted after 180 days, old versions after 90 days" >> $GITHUB_STEP_SUMMARY
        echo "- **IAM Role**: Jenkins EC2 instance has read/write access via IAM instance profile" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### â­ï¸ Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Merge this PR to main to trigger Ansible configuration" >> $GITHUB_STEP_SUMMARY
        echo "2. Jenkins will be automatically configured via Ansible" >> $GITHUB_STEP_SUMMARY
        echo "3. Access Jenkins at the URL above after configuration completes" >> $GITHUB_STEP_SUMMARY
        echo "4. Configure Jenkins to use S3 bucket \`${{ steps.tf_outputs.outputs.artifacts_bucket }}\` for artifact storage" >> $GITHUB_STEP_SUMMARY